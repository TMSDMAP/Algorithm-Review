/*
在H市中，有N个地铁站，编号为1 到 N。起初，这些地铁站之间没有任何地铁线路连接。

H市政府正在推行一项地铁整改计划，该计划包含Q条整改指令。你需要依照顺序处理这些指令，并在每条指令处理完毕后，统计当前完全孤立的地铁站数量（即没有与任何其他地铁站通过地铁线路相连的地铁站数量）。

每条整改指令有两种类型之一：

·1 u v：修建一条新的地铁线路，将地铁站u和地铁站v连接起来。可以保证在此指令执行之前，u和v之间没有直接的地铁线路。

·2 v：由于施工、调整等原因，拆除所有连接地铁站v与其他地铁站的地铁线路（注意：地铁站v本身不会被拆除，仅断开与其他站的所有连接）。

请你根据每条指令的执行结果，依次输出当前城市中完全孤立的地铁站数量。

出题人：高泽铭同学


输入

第一行包含两个整数N和Q，分别代表地铁站的总数和整改指令的数量。

接下来Q行，每行一条整改指令，格式如下：

·1 u v表示修建一条从地铁站u到地铁站v的地铁线路。

·2 v表示拆除所有连接地铁站v的地铁线路。


输出

对于每条整改指令，输出一个整数，表示H城市中完全孤立的地铁站数量。


输入样例 1

3 7
1 1 2
1 1 3
1 2 3
2 1
1 1 2
2 2
1 1 2
输出样例 1

1
0
0
1
0
3
1
输入样例 2

2 1
2 1
输出样例 2

2
提示

·2 ≤ N ≤ 3×10⁵

·1 ≤ Q ≤ 3×10⁵

·对于所有类型为1的整改指令，1 ≤ u, v ≤ N 且 u ≠ v，并且保证在该指令执行前，u与v没有直接连接。

·对于所有类型为2的整改指令，1 ≤ v ≤ N。*/

#include <iostream>
#include <vector>
#include <unordered_set>  //使用集合方便除边
using namespace std;

int main()
{
	int N, Q;
	cin >> N >> Q;
	vector<unordered_set<int>> g(N + 1); //使用unordered_set存储每个站点的连接，方便快速查找和删除
	vector<int> e(N + 1, 0);
	int sum = N;
	while (Q--)
	{
		int f;
		cin >> f;
		if (f == 1)
		{
			int a, b;
			cin >> a >> b;
			g[a].insert(b);
			g[b].insert(a);
			e[a]++;
			e[b]++;
			if (e[a] == 1) sum--;
			if (e[b] == 1) sum--; //如果是第一次连接，孤立站数减一
		}
		else {
			int b;
			cin >> b;
			for (int ne : g[b])
			{
				g[ne].erase(b); //从其他站点的连接中删除站点b
				if (e[ne] == 1) sum++; //如果之前只有一个连接，孤立站数加一
				e[ne]--; //减少其他站点的连接数
			}
			g[b].clear(); //清空站点b的连接
			if (e[b] != 0) sum++; //如果之前有连接，孤立站数加一
			e[b] = 0; //清空站点b的连接
		}
		cout << sum << endl;
	}
	return 0;
}