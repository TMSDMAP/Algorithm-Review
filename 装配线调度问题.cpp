/*
装配线调度问题描述
有两条装配线，每一条装配线上有 n 个装配点，将装配线 i 上的第 j 个装配点记为\(S_i[j]\)，
设在装配点\(S_i[j]\)的装配时间为\(a_i[j]\)。假设要装配一辆汽车，将汽车底盘从进厂点送入装配线 i（i = 1 或 2），
需要时间\(e_i\)。在装配点\(S_i[j]\)装配后，如果汽车传送到同一条装配线的装配点\(S_i[j + 1]\)进行装配，则传送不需要时间。
如果汽车从装配点\(S_i[j]\)传送到另一条装配线进行装配，则需要传送时间\(t_i[j]\)。汽车在装配点\(S_i[n]\)装配后，将汽车成品从装配线上取下来，
需要花费时间\(x_i\)。装配线调度问题是如何确定每一个装配点的装配需要在哪条线上进行，使得当汽车成品出来时，花费的总时间最少。
值得注意的是两条装配线的第 j 个装配点都装配同样的汽车部件，只是装配效率不一样。
输入

输入共 7 行

第一行一个数字，表示节点数n[2,10000]

第二行n个数字依次表示第一条流水线处理时间[1,100]

第三行n个数字依次表示第二条流水线处理时间[1,100]

第四行n-1个数字依次表示第一条流水线转至第二条流水线消耗时间[1,100]

第五行n-1个数字依次表示第二条流水线转至第一条流水线消耗时间[1,100]

第六行2个数字,分别表示送入流水线1和流水线2的入厂时间[1,100]

第七行2个数字,分别表示离开流水线1和流水线2的出场时间[1,100]


输出

输出最短时间
*/

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
	int n;
	cin >> n;

	vector<int> a1(n), a2(n);
	for (int i = 0; i < n; i++) 		cin >> a1[i];
	for (int i = 0; i < n; i++) 		cin >> a2[i];
	vector<int> t1(n - 1), t2(n - 1);
	for (int i = 0; i < n - 1; i++) 	cin >> t1[i];
	for (int i = 0; i < n - 1; i++) 	cin >> t2[i];

	int e1, e2, x1, x2;
	cin >> e1 >> e2;
	cin >> x1 >> x2;

	vector<int> T1(n), T2(n);
	T1[0] = e1 + a1[0];
	T2[0] = e2 + a2[0];

	for (int j = 1; j < n; j++)
	{
		T1[j] = min(T1[j - 1] + a1[j], T2[j - 1] + t2[j - 1] + a1[j]);
		T2[j] = min(T2[j - 1] + a2[j], T1[j - 1] + t1[j - 1] + a2[j]);
	}
	int result = min(T1[n - 1] + x1, T2[n - 1] + x2);
	cout << result << endl;
	return 0;
}