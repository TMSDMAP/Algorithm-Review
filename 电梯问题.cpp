/*
今天是世界电梯日！所有人在这一天都要坐电梯！

现在是9:40，学武楼的同学们要在这个时间换教室。现在有n个同学需要坐电梯上下楼，对于第 i 个同学来说，他需要从第 x_i 层坐电梯到第 y_i 层(x_i<y_i)。

众所周知，学武楼只有一个电梯，所有人都需要等它。而为了让每个坐电梯的同学有一个良好的体验，电梯同一时间只能有一个人，且只能向上坐。电梯初始停在第s 层，可以随意向上/下移动，也可以在任意楼层让同学上电梯。

但是电梯，是要耗电的！学武楼电梯采用了节能的设计：当电梯上行时，每向上一层需要消耗1 单位的电量；而当电梯下行时，电梯依靠自重下行，并不需要消耗电量。聪明的百德仁马上想到了如何安排电梯的行动，才能使得所有同学到达目的地，并且电梯的总耗电最少。请你求出这个最小值。

出题人：栾英石同学


输入

第一行两个整数n,s ，分别表示同学的数量，和电梯初始的楼层。

第2~n+1行，每行两个整数l_i,r_i，表示第 i 个人想从第 l_i 层坐电梯到第 r_i 层


输出

一个正整数，代表电梯总耗电量的最小值。


输入样例 1

4 2
3 6
1 3
2 7
5 6
输出样例 1

11
提示

提示：如果电梯初始在无穷大层，总消耗电量的最小值如何考虑？

数据范围：

1<=n<=10^5 1<=l_i,r_i,f_i,s<=10^9
*/

#include <iostream>
#include <algorithm>
using namespace std;

struct Stu {
	int l;
	int r;
};  //// 学生结构体，包含起点l和终点r
 
bool compare(Stu a, Stu b) {
	if (a.l < b.l)
		return a.l < b.l;
	else if (a.l == b.l)
		return a.r > b.r;
	else
		return a.l < b.l;
}  //// 比较函数，用于排序学生，先按起点升序，如果起点相同则按终点降序排列
Stu stu[100005];
int main() {
	int n, s;
	cin >> n >> s;
	for (int i = 0; i < n; i++) {
		cin >> stu[i].l >> stu[i].r;
	}
	sort(stu, stu + n, compare);
	int sum = 0;
	// 1. 电梯从初始位置到第一个同学的起点（如果需要上行）
	if (stu[0].l < s)
		sum = 0;
	else if (stu[0].l > s)
		sum += stu[0].l - s;
	// 2. 每个同学从起点到终点的耗电量
	for (int i = 0; i < n; i++)
	{
		sum += stu[i].r - stu[i].l;
	}  // // 计算每个学生的上下行耗电量
		// 3. 电梯在相邻同学之间可能的额外上行耗电量
	for (int i = 1; i < n; i++)
	{
		if (stu[i].l - stu[i - 1].r > 0)
			sum += stu[i].l - stu[i - 1].r;
	}  // // 计算相邻学生之间的过渡耗电量，如果后一个学生的起点高于前一个学生的终点，则需要额外上行

	cout << sum << endl;
	return 0; 

}

/*
我们可以将电梯的总耗电量分为三部分：

初始移动耗电：从初始位置到第一个同学的起点可能需要上行，从高的入手
接送同学耗电：每个同学从起点到终点的上行耗电
同学之间的过渡耗电：对于相邻的两个同学，如果后一个同学的起点高于前一个同学的终点，电梯需要额外上行
*/