/*
在一个高科技果园中，林克利用先进的无人机将所有果子采集完毕，并通过智能分类系统按照果子的种类将它们分成了不同的堆。

林克决定通过纳米融合技术将所有果子合成一堆。

每次融合，林克可以选择两堆果子进行合并，消耗的能量等于两堆果子的重量之和，能量单位由果园的中央AI计算并记录。

显然，经过n-1次融合后，所有果子将整合为一堆。

林克在融合果子时总共消耗的能量等于每次融合所耗能量之和。

由于林克还需要驾驶悬浮运输机将这些果子运回基地，他希望在融合过程中尽可能节省能量，以便优化运输效率。

假设每个果子的重量为1个标准单位，并且已知果子的种类数和每种果子的数量，你的任务是设计出一种融合次序方案，使林克消耗的能量最少，并输出这个最小的能量值。

例如，有3种果子，数量依次为1、2、9。

林克可以先将1和2堆融合，新堆数量为3，消耗能量为3。

接着，将新堆与原先的第3堆融合，得到数量为12的新堆，消耗能量为12。

因此，林克总共消耗的能量为3+12=15。

可以证明，15是可能的最小能量值。

数据范围：

1 ≤ n ≤ 10000,

1 ≤ ai ≤ 20000

请根据此问题，计算出林克最小的能量消耗值，并说明你的方案。


输入

输入包括两行，第一行是一个整数n，表示果子的种类数。

第二行包含n个整数，用空格分隔，第i个整数ai是第i种果子的数目。


输出

输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。

输入数据保证这个值小于2^31。


输入样例 1

3
1 2 9
输出样例 1

15
*/

//经典哈夫曼树模型，每次合并最小的两堆，直到只剩下一堆
//使用小根堆维护所有果子，优先队列
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int main()
{
	int n;
	scanf("%d",&n);

	priority_queue<int, vector<int>, greater<int>> heap;
	while (n--)
	{
		int x;
		scanf("%d",&x);
		heap.push(x);
	}
	int res = 0;
	while (heap.size() > 1)
	{
		int a = heap.top(); heap.pop();
		int b = heap.top(); heap.pop();
		int sum = a + b;
		res += sum; // 累加能量消耗
		heap.push(sum);
	}
	printf("%d\n", res);
	return 0;
}